'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.zoomToShapes = exports.radiusChange = exports.removeAllFeatures = exports.incForce = exports.makePoints = exports.removeHandler = exports.removeListener = exports.polygonArrayToProp = exports.generateCircleApprox = exports.areaAccumulator = exports.indexByKey = exports.generateIcon = exports.makePoint = exports.makeCenterLeaflet = exports.onLocationSelect = undefined;

var _leaflet = require('leaflet');

var _leaflet2 = _interopRequireDefault(_leaflet);

var _noop = require('lodash/noop');

var _noop2 = _interopRequireDefault(_noop);

var _remove = require('lodash/remove');

var _remove2 = _interopRequireDefault(_remove);

var _map2 = require('lodash/map');

var _map3 = _interopRequireDefault(_map2);

var _range = require('lodash/range');

var _range2 = _interopRequireDefault(_range);

var _reverse = require('lodash/reverse');

var _reverse2 = _interopRequireDefault(_reverse);

var _flatten = require('lodash/flatten');

var _flatten2 = _interopRequireDefault(_flatten);

var _cloneDeep = require('lodash/cloneDeep');

var _cloneDeep2 = _interopRequireDefault(_cloneDeep);

var _mathjs = require('mathjs');

var _mathjs2 = _interopRequireDefault(_mathjs);

var _cleanProps = require('./cleanProps');

var _cleanProps2 = _interopRequireDefault(_cleanProps);

var _getBounds = require('./getBounds');

var _getBounds2 = _interopRequireDefault(_getBounds);

var _updateShapes = require('./updateShapes');

var _updateShapes2 = _interopRequireDefault(_updateShapes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var validCoordsArray = function validCoordsArray(arr) {
  return arr && arr.length && arr.length === 2 && arr[0] < 180 && arr[0] > -180 && arr[1] < 90 && arr[1] > -90;
};

var validLatlngObject = function validLatlngObject(c) {
  return typeof c.lat === 'number' && typeof c.lng === 'number';
};
var validGeoJSONPoint = function validGeoJSONPoint(c) {
  return c.type === 'Point' && validCoordsArray(c.coordinates);
};
var validGeoJSONPointFeature = function validGeoJSONPointFeature(c) {
  return c.type === 'Feature' && validGeoJSONPoint(c.geometry);
};

var onLocationSelect = exports.onLocationSelect = function onLocationSelect(props, loc) {
  var _loc$gmaps$geometry$v = loc.gmaps.geometry.viewport,
      j = _loc$gmaps$geometry$v.j,
      l = _loc$gmaps$geometry$v.l,
      b = _loc$gmaps$geometry$v.b,
      f = _loc$gmaps$geometry$v.f,
      ea = _loc$gmaps$geometry$v.ea,
      la = _loc$gmaps$geometry$v.la;

  var b1 = void 0;
  var b2 = void 0;
  if (b && f) {
    b1 = _leaflet2.default.latLng(f.b, b.b);
    b2 = _leaflet2.default.latLng(f.f, b.f);
  } else if (j && l) {
    b1 = _leaflet2.default.latLng(l.j, j.j);
    b2 = _leaflet2.default.latLng(l.l, j.l);
  } else if (ea && la) {
    b1 = _leaflet2.default.latLng(la.j, ea.j);
    b2 = _leaflet2.default.latLng(la.l, ea.l);
  } else {
    b1 = false;
    b2 = false;
  }

  var bounds = void 0;
  if (b1 && b2) {
    bounds = _leaflet2.default.latLngBounds(b1, b2);
  } else {
    bounds = false;
  }
  var p = (0, _cloneDeep2.default)(props);
  p.center = {
    type: 'Feature',
    properties: {
      bounds: bounds
    },
    geometry: {
      coordinates: [loc.location.lng, loc.location.lat],
      type: 'Point'
    }
  };
  p.points.push(p.center);

  (0, _cleanProps2.default)(p, props.onShapeChange, _noop2.default);

  props.bindPoint.leafletElement.fitBounds(_leaflet2.default.latLngBounds(b1, b2));
};

// input a geoJSON point geometry
var makeCenterLeaflet = exports.makeCenterLeaflet = function makeCenterLeaflet(c) {
  if (c.lat && c.lng) return _leaflet2.default.latLng(c);
  if (validGeoJSONPointFeature(c)) {
    var coords = c.geometry.coordinates;
    return _leaflet2.default.latLng(coords[1], coords[0]);
  }
  if (validGeoJSONPoint(c)) return _leaflet2.default.latLng(c.coordinates[1], c.coordinates[0]);
  return {};
};

var makePoint = exports.makePoint = function makePoint(cee) {
  var c = (0, _cloneDeep2.default)(cee);
  if (!c) return { type: 'Point', coordinates: [-85.751528, 38.257222] };
  if (validCoordsArray(c)) return { type: 'Point', coordinates: (0, _reverse2.default)(c) };
  if (validLatlngObject(c)) return { type: 'Point', coordinates: [c.lng, c.lat] };
  if (validGeoJSONPoint(c)) return c;
  if (validGeoJSONPointFeature(c)) return c.geometry;
  return { type: 'Point', coordinates: [-85.751528, 38.257222] };
};

var generateIcon = exports.generateIcon = function generateIcon(html) {
  return new _leaflet2.default.divIcon({
    className: 'my-div-icon',
    html: html
  });
};

var indexByKey = exports.indexByKey = function indexByKey(arr, key) {
  var index = -1;
  (0, _map3.default)(arr, function (val, ind) {
    if (val.properties && val.properties.key === key) index = ind;
  });
  return index;
};

var areaAccumulator = exports.areaAccumulator = function areaAccumulator(sum, val) {
  return sum + val.properties.area;
};

var radians = function radians(deg) {
  return deg / 360 * 2 * Math.PI;
};

var rotatedPointsOrigin = function rotatedPointsOrigin(radius, sides) {
  var z = new _mathjs2.default.complex({ phi: 0, r: radius });
  var angle = 2 * Math.PI / sides;
  return (0, _map3.default)((0, _range2.default)(sides), function (x) {
    var point = _mathjs2.default.multiply(z, _mathjs2.default.exp(_mathjs2.default.multiply(x, angle, _mathjs2.default.complex(0, 1))));
    return [_mathjs2.default.re(point), _mathjs2.default.im(point)];
  });
};

var translatePoints = function translatePoints(points, c) {
  return (0, _map3.default)(points, function (point) {
    return [point[0] + c.lat, point[1] + c.lng];
  });
};

var scalePoints = function scalePoints(points, lat) {
  var factor = _mathjs2.default.cos(radians(lat)) * 69.172;
  return (0, _map3.default)(points, function (x) {
    return [x[0] / 69.172, x[1] / factor];
  });
};

var generateCircleApprox = exports.generateCircleApprox = function generateCircleApprox(radius, unit, center, sides) {
  var c = makeCenterLeaflet(center);
  var points = rotatedPointsOrigin(radius, sides);
  var scaledPoints = scalePoints(points, c.lat);
  var translatedPoints = translatePoints(scaledPoints, c);
  var reversedPoints = (0, _map3.default)(translatedPoints, function (x) {
    return (0, _reverse2.default)(x);
  });
  return {
    type: 'Feature',
    properties: {
      radius: radius,
      unit: unit,
      center: center,
      sides: sides
    },
    geometry: {
      type: 'MultiPolygon',
      coordinates: [[reversedPoints]]
    }
  };
};

var polygonArrayToProp = exports.polygonArrayToProp = function polygonArrayToProp(polys) {
  return (0, _map3.default)(polys, function (poly) {
    // Don't rechange polys coming from map edit
    if (poly.geometry.type === 'Polygon') {
      return poly;
    }
    // Can't do anything with a non-trivial MultiPolygon
    if (poly.geometry.coordinates[0].length > 1) {
      var p = poly.properties;
      p.noEdit = true;
      return {
        type: 'Feature',
        geometry: {
          type: 'Polygon',
          coordinates: (0, _flatten2.default)(poly.geometry.coordinates)
        },
        properties: p
      };
    }
    return {
      type: 'Feature',
      geometry: {
        type: 'Polygon',
        coordinates: (0, _flatten2.default)(poly.geometry.coordinates)
      },
      properties: poly.properties
    };
  });
};

var removeListener = exports.removeListener = function removeListener(props, next) {
  var p = (0, _cloneDeep2.default)(props);
  p.remove = next;
  (0, _cleanProps2.default)(p, props.onShapeChange, _noop2.default);
};

var removeHandler = exports.removeHandler = function removeHandler(props) {
  var p = (0, _cloneDeep2.default)(props);
  p.remove = !props.remove;
  (0, _cleanProps2.default)(p, props.onShapeChange, _noop2.default);
};

var makePoints = exports.makePoints = function makePoints(arr) {
  return (0, _map3.default)(arr, makePoint);
};

// TODO: Get rid of this nasty hack
var incForce = exports.incForce = function incForce(obj) {
  var o = (0, _cloneDeep2.default)(obj);
  if (obj.force) {
    o.force = obj.force + 1;
    return o;
  }
  o.force = 1;
  return o;
};

var removeAllFeatures = exports.removeAllFeatures = function removeAllFeatures(props) {
  var p = (0, _cloneDeep2.default)(props);
  (0, _remove2.default)(p.features, function () {
    return true;
  });
  (0, _remove2.default)(p.points, function () {
    return true;
  });
  (0, _cleanProps2.default)(p, props.onShapeChange, _noop2.default);
};

var radiusChange = exports.radiusChange = function radiusChange(props, e) {
  var p = (0, _cloneDeep2.default)(props);
  p.newCircleRadius = e;
  (0, _cleanProps2.default)(p, props.onShapeChange, _noop2.default);
};

var zoomToShapes = exports.zoomToShapes = function zoomToShapes(props, _map) {
  if (_map && _map.leafletElement) {
    var features = props.features,
        points = props.points;

    if (features.length > 0 || points.length > 0) {
      var bounds = (0, _getBounds2.default)(features, points);
      _map.leafletElement.fitBounds(bounds);
    }
  }
};